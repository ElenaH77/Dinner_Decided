// Custom hook to improve recipe quality on the client side
import { useState, useEffect } from 'react';
import { validateRecipeInstructions } from '@shared/recipe-validation';
import { regenerateInstructions } from '@/lib/recipe-generator';

// Custom hook for checking recipe quality throughout the app
export function useRecipeQuality(mealPlan: any) {
  const [improvedMealPlan, setImprovedMealPlan] = useState(mealPlan);
  
  // Whenever the meal plan changes, check if any recipes need quality improvements
  useEffect(() => {
    if (!mealPlan || !mealPlan.meals || !Array.isArray(mealPlan.meals)) {
      return;
    }
    
    console.log('[RECIPE QUALITY] Checking recipe quality for meal plan');
    
    // Define an async function to process the meal plan with OpenAI
    const improveMealPlanAsync = async () => {
      try {
        // Track whether any improvements are needed
        let needsImprovement = false;
        
        // Process each meal, potentially using async OpenAI regeneration
        const improvedMealsPromises = mealPlan.meals.map(async (meal: any) => {
          if (!meal || !meal.instructions) {
            return meal;
          }
          
          // Use the validation utility
          const validationResult = validateRecipeInstructions(meal.instructions);
          
          // Only regenerate if there are actual issues
          if (!validationResult.isValid || meal._needsRegeneration) {
            needsImprovement = true;
            console.log(`[RECIPE QUALITY] Issues found in "${meal.name}":`, validationResult.issues);
            
            // Only attempt OpenAI regeneration if we have both name and ingredients
            if (meal.name && meal.ingredients && meal.ingredients.length > 0) {
              try {
                console.log(`[RECIPE QUALITY] Regenerating instructions for "${meal.name}" via OpenAI API`);
                
                // Call the API to get new instructions
                const newInstructions = await regenerateInstructions({
                  name: meal.name,
                  ingredients: meal.ingredients
                });
                
                if (newInstructions && newInstructions.length >= 5) {
                  console.log(`[RECIPE QUALITY] Successfully regenerated ${newInstructions.length} instructions for "${meal.name}"`);
                  
                  // Create an improved recipe with the new instructions
                  return {
                    ...meal,
                    instructions: newInstructions,
                    directions: newInstructions, // For backward compatibility
                    _needsRegeneration: false,
                    _qualityIssues: [],
                    _instructionsImproved: true,
                    _regeneratedAt: new Date().toISOString()
                  };
                } else {
                  console.log(`[RECIPE QUALITY] Failed to get valid instructions from API for "${meal.name}"`);
                  
                  // If OpenAI regeneration fails, mark the recipe but don't use any template fallbacks
                  return {
                    ...meal,
                    _needsRegeneration: true,
                    _qualityIssues: [...(meal._qualityIssues || []), "Instructions could not be regenerated by AI"],
                    _regenerationFailed: true
                  };
                }
              } catch (error) {
                console.error(`[RECIPE QUALITY] API error while regenerating "${meal.name}":`, error);
              }
            }
            
            // If OpenAI regeneration failed, add a note but don't modify the recipe
            console.log(`[RECIPE QUALITY] No instructions regenerated for "${meal.name}"`);
            return {
              ...meal,
              _needsRegeneration: true,
              _qualityIssues: validationResult.issues
            };
          }
          
          return meal;
        });
        
        // Wait for all async regenerations to complete
        const improvedMeals = await Promise.all(improvedMealsPromises);
        
        // Only update if we actually made improvements
        if (needsImprovement) {
          // Create a new meal plan with improved recipes
          const newMealPlan = {
            ...mealPlan,
            meals: improvedMeals,
            lastQualityCheck: new Date().toISOString()
          };
          
          console.log('[RECIPE QUALITY] Setting improved meal plan with fixed recipes');
          setImprovedMealPlan(newMealPlan);
        } else {
          console.log('[RECIPE QUALITY] No quality issues found in meal plan');
          setImprovedMealPlan(mealPlan);
        }
      } catch (error) {
        console.error('[RECIPE QUALITY] Error improving meal plan:', error);
        // In case of error, use the original meal plan
        setImprovedMealPlan(mealPlan);
      }
    };
    
    // Execute the async function
    improveMealPlanAsync();
  }, [mealPlan]);
  
  return improvedMealPlan;
}